按照要求，使用Ubuntu作为操作系统。按照个人习惯，使用CLion作为IDE，语言标准为C++23。

# 设计思路

![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/29543181/1760786316817-65b90e2c-3ee7-43c2-951e-b5899d48dcff.jpeg)

除流程图中所展示的之外，应当在用户每次输入时检查输入内容是否符合格式（比如输入密钥中，参数必须是整型），若不符合格式，则要求用户重新输入。

# 代码编写

首先是欢迎语：

```cpp
std::cout
    << R"( _   _  _____  _      _       _____    ____  _     _)" << std::endl
    << R"(| |_| ||  ___|| |    | |     / ___ \  / ___|| |   | |)" << std::endl
    << R"(|  _  ||  ___|| |    | |    / /   \ \/ /    | |   | |)" << std::endl
    << R"(| | | || |___ | |___ | |___ \ \___/ /\ \___  \ \_/ /)" << std::endl
    << R"(|_| |_||_____||_____||_____| \_____/  \____|  \___/)" << std::endl
    << "第二阶段第二周考核任务" << std::endl
    << "CryptoTool By CyberKanjousen" << std::endl;
    << "仅支持ASCII编码字符的加密/解密" << std::endl;
```

> 这种用`|` `\` `/`等字符构成的Logo在命令行程序中相当常见，比如SpringBoot、SpigotMC等。
>

由于Logo部分存在字符`\`，而使用转义字符`\\`会打乱代码在编辑器中的排列方式，因此为了美观，使用`R"(字符串)"`的形式。

该程序的仅支持ASCII编码字符的加密或解密，这一点必须强调一下（UTF-8的加密实现起来太复杂了）

接下来是菜单。按照要求，需要写一个`Menu`类，负责显示命令行菜单并处理用户输入：

![](https://cdn.nlark.com/yuque/0/2025/png/29543181/1760688626062-dc38c1b4-9cf1-4fc7-ba24-d044b042147a.png)

后来把命名空间改成了`crypto_tool`。在我看来，C++的命名空间可以类比《Minecraft: Java Edition》（《MCJE》）的命名空间。比如：由命名空间ID`minecraft:grass_block`中的`minecraft`可知草方块来自《MCJE》原版，而由`immersiveengineer:lead_ingot`中的`immersiveengineer`可知铅锭来自“沉浸工程”模组。C++命名空间的作用同样也可以类比《MCJE》，比如：“机械动力”模组和“沉浸工程”模组都有铜锭（ID相同）（1.16.5前），前者的命名空间ID为`immersiveengineer:copper_ingot`，后者为`create:copper_ingot`，这里的命名空间起到了区分的作用，保证程序能够区分这两种铜锭。

> 分文件写类是个好习惯。——718实验室的ldx如是说
>

> C++撰写类分成两个文件，`.h`文件负责定义，`.cpp`文件负责实现。一个`.h`文件可定义多个类，`.cpp`文件可以实现多个类。
>

在我看来，之所以要这样设计，应该是为了方便一个方法在不同的地方有不同的实现方式，这个和Java重写抽象方法有点像。

CLion自动生成了两个文件的基本格式：

```cpp
//
// Created by cyberkanjousen on 2025/10/17.
//

#ifndef ENCRYPTAPPLICATION_CRYPTO_TOOL_H
#define ENCRYPTAPPLICATION_CRYPTO_TOOL_H

namespace crypto_tool {
    class Menu {
    };
} // crypto_tool

#endif //ENCRYPTAPPLICATION_CRYPTO_TOOL_H
```

在这里，只写方法头而不写方法体。（语法上在这里写方法体也是对的。如果没有`crypto_tool.cpp`的话，可以让`crypto_tool.cpp`实现方法。）

可以给一个变量赋一个初始值，这一点和在`.cpp`文件内一样。

```cpp
//
// Created by cyberkanjousen on 2025/10/17.
//

#include "crypto_tool.h"

namespace crypto_tool {
} // crypto_tool
```

在这里，既写方法头，又写方法体。

此处的方法名前要加`类名::`，否则不会对`.h`文件内的抽象方法进行重写（借用一下Java的说法），而是另外声明一个新方法。

可以开始写`Menu`的方法了。首先是展示各级菜单的方法：

```cpp
void Menu::show_menu() const {
    switch (menuArg) {
        case 0:
            std::cout
            << "请输入字符串" << std::endl
            << ">";
            break;
        case 1:
            std::cout
            << "选择操作对象类型" << std::endl
            << "1:文本文件（.txt文件格式，ASCII编码）" << std::endl
            << "2:文本字符串（ASCII编码）" << std::endl
            << "3:退出" << std::endl
            << ">";
            break;
        case 2:
            std::cout
            << "选择加密/解密" << std::endl
            << "1:解密" << std::endl
            << "2:加密" << std::endl
            << "3:退出" << std::endl
            << ">";
            break;
        case 3:
            std::cout
            << "选择文件路径" << std::endl
            << ">";
            break;
        case 4:
            std::cout
            << "输入密钥并选择" << (ifEncrypt? "加": "解") << "密模式" << std::endl
            << "可选:" << std::endl
            << "凯撒密码: <number(0-94)>-cc 如: 42-cc" << std::endl
            << "异或密码: <number(0-94)>-xor 如: 42-xor" << std::endl
            << ">";
            break;
        default:
            break;
    }
}
```

其中`manuArg`是`Menu`类的一个公共变量，表示当前菜单页面所代表的参数。

由于这个方法没有改变`Menu`类的其他成员，因此在编辑器的建议下，将其声明为静态方法。

C++的方法名一般用下划线命名法。我当初误用了大驼峰，大驼峰是类的命名方法。（应当保持良好命名习惯，不要像*微信*程序员那样胡乱命名。）

之后就可以写处理用户输入的方法了。用户输入值的类型有3种：菜单选项、文件路径、密钥。我首先在`main.cpp`写下这些用户输入处理方法的逻辑：

```cpp
crypto_tool::Menu menu;
while (menu.ifRun) {
    menu.show_menu();
    switch (menu.menuArg) {
        case 0:
            menu.string_input(); // 输入字符串
            break;
        case 3:
            menu.road_input(); // 输入文件路径
            break;
        case 4:
            menu.key_input(); // 输入密钥
            break;
        default:
            menu.menu_select(); // 输入菜单选项
            break;
    }
}
std::cout << "程序已退出" << std::endl;
```

其中`ifRun` `ifEncrypt`分别是`Menu`类的一个公共变量和一个私有变量，分别表示程序是否应当运行和是否为加密模式，初始量为`true`。

然后再写这些方法的实现。

输入菜单选项的方法：

```cpp
void Menu::menu_select() {
    std::string input;
    char *ptr;
    std::getline(std::cin, input);
    char input_char[2];
    input_char[0] = input[0];
    const long ret = strtol(input_char, &ptr, 10);
    switch (menuArg) {
        case 1:
            switch (ret) {
            case 1:
                ifFile = true;
                menuArg = 3;
                break;
            case 2:
                ifFile = false;
                menuArg = 0;
                break;
            case 3:
                ifRun = false;
                    break;
            default:
                    ERR("错误: 无效的选项");
                    break;
            }
            break;
        case 2:
            switch (ret) {
            case 1:
                    ifEncrypt = false;
                    menuArg = 4;
                    break;
            case 2:
                    ifEncrypt = true;
                    menuArg = 4;
                    break;
            case 3:
                    ifRun = false;
                    break;
            default:
                    ERR("错误: 无效的选项");
                    break;
            }
            break;
        default:
            break;
    }
}
```

这个方法对`Menu`的成员产生了改变，所以不能声明成静态方法。

`ifFile`是`Menu`类的一个私有变量，表示操作对象是否为文本文件，初始值都为`true`。

`ret`一直是初始值不变，所以为了优化，声明为一个常量。

`ERR(STRING)`是在头文件部分定义的一个宏，详见[后文](#stdcerr慢于stdcout)。

本来输入那一部分用是用之前学到的`scanf()`实现的，但是编辑器却如是提示道：

> Clang-Tidy: 'scanf' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead
>

所以改用`getline()` `strtol()`方法（顺便还能应对用户不按格式输入的情况）。顺便一提，在Windows上的C++26，用`scanf()`的话编译总是报错，改用`scanf_s()`就可以了——然而在Ubuntu上，我的编辑器显示不存在`scanf_s()`方法。

> 处理用户输入的方法参考了[此处](https://stackoverflow.com/questions/50794976/clion-recommends-to-use-strtol-instead-of-scanf)。
>
> `strtol()`用来将字符串形式的“数字”转化为长整型。
>

> 把参数`str`所指向的字符串根据给定的`base`转换为一个长整数（类型为`long int`型），`base`必须介于`2`和`36`（包含）之间，或者是特殊值`0`。
>
> + `str` -- 要转换为长整数的字符串。
> + <`endptr` -- 对类型为`char*`的对象的引用，其值由函数设置为`str`中数值后的下一个字符。
> + `base` -- 基数，必须介于`2`和`36`（包含）之间，或者是特殊值`0`。如果`base`为 0，则会根据字符串的前缀来判断进制：如果字符串以`0x`或`0X`开头，则将其视为十六进制；如果字符串以`0`开头，则将其视为八进制；否则将其视为十进制。
>
> 出自[runoob.com](https://www.runoob.com/cplusplus/cpp-inheritance.html)
>

然后是输入文件路径的方法。由于有写一个`FileHandler`类以负责文件的读取和保存的要求，这里把读取文件的方法给到`FileHandler`类中：

```cpp
void Menu::road_input() {
    std::string input;
    std::cin >> input;
    if (input.substr(input.size() - 4, 4) != ".txt") {
        ERR("错误: 目标文件必须是.txt文件");
        return;
    }
    try {
        if (const std::string ret = FileHandler::read_file(input);
            !ret.empty()) { // 适当换行，增加代码可读性
            str = ret;
            fileRoad = input;
        } else {
            ERR("错误：目标文件不能为空");
        }
        menuArg = 2;
    } catch (std::exception& e) {
        ERR(e.what());
        ERR("错误：文件路径无效");
    }
}
```

`StringObject.contains(_CharT __x)`方法仅在C++23及以上可用。在仅支持C++17的HydroOJ洛谷习题上，我一般用`StringObject.find(const std::string __str) != StringObject.end()`代替。

`str`和下文提到的`fileRoad`是`Menu`类的两个公共变量，用于存储待加密或解密的字符串和文件路径。

在C++中，使用静态方法的格式是`类名::方法名(...)`（处于不同命名空间时还要加命名空间）。这一点要和Java区分，我经常写成`类名.方法名()`，直到编辑器报错才知道改正。

使用`try/catch`语句，保护存取文件的代码，防止存取文件出错而影响程序运行。

`FileHandler`类包含文件读取方法和文件保存（将加密或解密完成的文件输出）方法。分别实现如下：

```cpp
std::string FileHandler::read_file(const std::string& road) {
    std::ifstream in(road);
    const std::istreambuf_iterator begin(in);
    const std::istreambuf_iterator<char> end;
    std::string str(begin, end);
    in.close();
    return str;
}

void FileHandler::save_file(const std::string &content, const std::string &file_road) {
    std::ofstream out(file_road);
    out << content;
    out.close();
    std::cout << "文件已经保存至'" << file_road << "'" << std::endl;
}
```

如果在函数的参数中，写的是`std::string arg`形式，那么编辑器会警告：

> Clang-Tidy: The const qualified parameter 'road' is copied for each invocation; consider making it a reference
>

从警告内容来看，写成`std::string arg`形式会导致在每次调用该参数时都会进行一次复制，这会在一定程度上影响性能，所以应该加上`&`（并且声明为常量）。

这里使用了文件流`fstream`库。在读取文件时，用到了迭代器`istreambuf_iterator`，比用循环一个一个读取要快一些。

利用流插入运算符`<<`可将内容输出到目标文件里。

用完文件要关上，和随手关门的是一个道理。

> 第3-6行的代码以及`std::istreambuf_iterator`的用法参考了[此处](https://en.cppreference.com/w/cpp/iterator/istreambuf_iterator.html)。
>

回到`Menu`类，还有输入字符串的方法需要实现：

```cpp
void Menu::string_input() {
    std::string input;
    std::getline(std::cin, input);
    str = input;
    menuArg = 2;
}
```

输入密钥方法的实现：

```cpp
void Menu::key_input() {
    std::string input;
    std::string res;
    char *ptr;
    std::getline(std::cin, input);
    const long ret = strtol(input.c_str(), &ptr, 10);
    if (ret < 0
        || ret > 94
        || input.empty()
        || !input.contains('-')
        || (input.substr(input.find('-') + 1, input.size() - input.find_last_of('-') - 1) != "cc"
            && input.substr(input.find_last_of('-') + 1, input.size() - input.find_last_of('-') - 1) != "xor"
        )
    ) {
        ERR("错误: 输入密钥无效");
        return;
    }
    if (ifEncrypt) {
        try{
            res = Crypto::encrypt(ret, str, input.substr(input.find_last_of('-') + 1, input.size() - input.find_last_of('-') - 1));
            std::cout << "加密完成，结果为: " << res << std::endl;
        } catch (const std::exception &e) {
            ERR(e.what());
            ERR("加密失败：原文存在非法字符");
            initialize();
        }
    } else {
        try{
            res = Crypto::decrypt(ret, str, input.substr(input.find_last_of('-') + 1, input.size() - input.find_last_of('-') - 1));
            std::cout << "解密完成，结果为: " << res << std::endl;
        } catch (const std::exception &e) {
            ERR(e.what());
            ERR("解密失败：原文存在非法字符");
            initialize();
        }
    }
    try{
        if (ifFile) {
            const std::string newFileRoad = fileRoad.insert(fileRoad.find_last_of('.'), "-output");
            FileHandler::save_file(res, newFileRoad);
        }
        initialize();
    } catch (std::exception& e) {
        ERR(e.what());
        ERR("错误: 保存失败");
    }
}
```

按照要求，负责加密和解密逻辑的方法给到了`Crypto`类中。

在这里，首先判断密钥是否有效，然后将执行`Crypto`类中的加密或解密方法。如果对象是文件，还额外执行文件保存方法。

> std::string::insert()的用法参考了[此处](https://cplusplus.com/reference/string/string/insert/)。
>

`initialize()`方法是将一系列参数初始化，实现如下： （好习惯）

```cpp
void Menu::initialize() {
    menuArg = 1;
    ifFile = true;
    ifEncrypt = true;
    str = "";
    fileRoad = "";
    key = 0;
}
```

接下来着手实现加密和解密方法。

程序提供了两种加密方法：凯撒密码和异或密码。

凯撒密码：将原文可显示字符（跳过控制字符）的ASCII码加上密钥的值（若超过了可显示字符的范围（32-126），则减去95,使之回到可显示字符范围）。

异或密码：将原文字符的ASCII码与密钥的值进行异或计算。由于异或计算之后的值可能落在可显示字符范围之外，所以异或计算后的值不会转化为对应的图形，而是以`[十六进制值]`的形式存在。

至于解密方法，将加密方法反过来实现就可以了。

加密、解密的方法具体实现如下：

```cpp
std::string Crypto::encrypt(const long key, const std::string& str, const std::string& mode) {
    std::string res;
    if (mode == "cc") {
        for (const unsigned char s : str) {
            if (int i = s; i >= 32 && i <= 126) {
                i += static_cast<int>(key);
                i = i > 126? i - 95: i;
                res += static_cast<char>(i);
            } else {
                res += static_cast<char>(s);
            }
        }
    } else if (mode == "xor") {
        for (const unsigned char s : str) {
            unsigned int i = static_cast<unsigned char>(s);
            i ^= static_cast<unsigned int>(key);
            char h[6];
            sprintf(h, "0x0%x", i);
            res += '[';
            res.append(h); // std::string字符串和char字符串用加号连起来会导致编辑器警报。
            res += ']';
        }
    }
    return res;
}

std::string Crypto::decrypt(const long key, const std::string& str, const std::string& mode) {
    std::string res;
    if (mode == "cc") {
        for (const unsigned char s : str) {
            if (int i = s; i >= 32 && i <= 126) {
                i -= static_cast<int>(key);
                i = i < 32? i + 95 : i;
                res += static_cast<char>(i);
            } else {
                res += static_cast<char>(s);
            }
        }
    } else if (mode == "xor") {
        bool ifTran = false;
        std::string h;
        for (const unsigned char s : str) {
            if (s == '[') {
                ifTran = true;
            } else if (s == ']') {
                ifTran = false;
                char *ptr;
                unsigned int i = std::strtol(h.c_str(), &ptr, 16);
                i ^= static_cast<unsigned int>(key);
                res += static_cast<char>(i);
                h = "";
            } else if (ifTran) {
                h += static_cast<char>(s);
            }
        }
    }
    return res;
}
```

> 十进制整型转十六进制格式的字符串的实现参考[此处](https://blog.csdn.net/amin_hui/article/details/122998740)。
>

# 遇到的问题

## std::string::data()
在编写处理用户输入方法的实现时，我发现：

```cpp
std::string input;
scanf("%s", input.data()); // 在这里若写成input而非input.data()，编辑器会警报。
```

然后输入任意字符串，回车。此时`input`的值并非输入的值，而是初始值`""`。根据[此处](about:blank)的说法，`input.data()`返回的指针并不是`input`的，虽然值和input相同。所以不管是`scanf()`还是`sprintf()`之类对参数对象赋值的方法，如果参数对象是`input.data()`，都不会对`input`本身进行赋值。

`std::string::c_str()`同理。

## fgets()
仍然是在编写处理用户输入方法的实现时：

```cpp
std::cout << ">";
// ...
char input[114514];
fgets(input, 1, stdin);
```

这并不会给用户输入字符的机会，因为程序运行第4行代码时，`input`的值就已经是`">"`而非预期中的`""`了。

结合[此处](about:blank)的说法，我发现`fgets(..., ..., stdin)`会读取终端页面末端一整行的前`n`个字符（`n`是该函数的第二个参数）并赋值给一个变量。因此`input`的值才会被赋成`">"`。

我后来改成了：

```cpp
std::getline(std::cin, input);
char input_char[2];
input_char[0] = input[0];
```

效果是一样的。从过程上来看，`fget()`不会读取`input`第二位及以后的字符。

## 字符串中字符的序号应当从0开始
非常基础的道理。但是我发现在使用`std::string::substr()`之类对字符串进行操作的方法时，总是会想当然地把第一个字符的序号当成1来算，直到debug才发现错误。

## std::cerr慢于std::cout
是的，错误流可能比输出流速度慢。如果错误信息用`std::cerr`输出的话，程序debug中模拟用户输入格式错误时的终端输出是这样的：![](https://cdn.nlark.com/yuque/0/2025/png/29543181/1760774227504-f2fe2aeb-6fe6-4e0b-bebf-166bd0d2530f.png)

显然，`错误: 无效的选项`和菜单1的输出顺序颠倒了，应当先输出菜单1才对。

原因大概如下：

> cerr is _tied_ to the standard output stream cout (see ios::tie), which indicates that cout's buffer is _flushed_ (see ostream::flush) before each i/o operation performed on cerr.
>
> 出自[cplusplus.com](https://cplusplus.com/reference/iostream/cerr/)
>

`std::cout`的缓冲区刷新先于输入输出流在`std::cerr`上的操作，并且`std::cerr`不走缓冲区，因而两者在IDE上的顺序可能和在终端上输出的顺序不同。所以为了保证顺序正常，我把`std::cerr`都换成了`std::cout`。不过这样一来，错误信息的字符颜色就和正常信息的没有区别了。为了把错误信息搞成红色，可以在字符串的开头加上`\033[31m`（恢复原色是`\033[m`）。为了减少重复性的编写，我写了个宏定义：（参考[此处](about:blank)）

```cpp
#define ERR(STRING) std::cout << "\033[31m" << STRING << "\033[m" << std::endl
```

![](https://cdn.nlark.com/yuque/0/2025/png/29543181/1760776306122-6d7b87a7-65f7-4d9c-8240-d266ce7ed339.png)

现在是正确的顺序了。

## std::cin.clear()
我曾经在`menu_select()`方法中使用`std::getline(std::cin, input)`输入，又在`key_input()`方法中使用`std::cin >> input`输入，结果在debug时：

![](https://cdn.nlark.com/yuque/0/2025/png/29543181/1760781271645-7de18faf-acdb-4f0d-ad57-9dd8387d0f95.png)

这是因为`std::cin << input`之后并不会清理缓冲区的数据，导致第二次调用`menu_select()`方法时，缓冲区的数据`114514`直接输入到`getline()`中了。其中一个解决方法是调用`std::cin.clear()`方法。由于`getline()`可以自动清理缓冲区，所以`getline()`可以不用配上`std::cin.clear()`——所以我选择全用`getline()`（`getline()`还可以读取空格）。

[语雀笔记页面](https://www.yuque.com/u29112212/ucgrla/pa9ft492me6vliqg)